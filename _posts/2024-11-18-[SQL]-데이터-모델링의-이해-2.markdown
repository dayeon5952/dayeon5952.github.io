---
title: "[SQL] 데이터 모델링의 이해 2"
date: 2024-11-18 21:56:23 +09:00
categories: [SQL]
tags: [SQL]
---
## **데이터 모델과 성능**

### **성능 데이터 모델링**

데이터베이스 성능 향상을 목적으로 설계단계의 데이터 모델링 때부터 성능과 관련된 사항이 데이터모델링에 반영될 수 있도록 하는 것

#### **성능 데이터 모델링 특징**

- 데이터의 증가가 빠를수록 성능저하에 따른 성능개선비용 증가
- 데이터모델은 성능을 튜닝하면서 변경 될 수 있음
- 분석/설계 단계에서 성능을 고려한 데이터 모델링을 수행할 경우 성능저하에 따른 Rework 비용을 최소화할 수 있는 기회를 가지게 됨

#### **성능 데이터 모델링 수행절차**

1. 데이터 모델링을 할 때 정규화를 정확하게 수행
2. 데이터베이스 용량산정을 수행
3. 데이터베이스에 발생되는 트랜잭션의 유형을 파악
4. 용량과 트랜잭션의 유형에 따라 <span style="background-color:#fff5b1;">반정규화</span>를 수행
5. 이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 등을 수행
6. 성능관점에서 데이터 모델을 검증

### **정규화**

#### **제 1 정규화**

- 모든 속성은 반드시 하나의 값을 가져야 한다. 즉, 반복 형태가 있어서는 안된다.
- 각 속성의 모든 값은 동일한 형식어야 한다.
- 각 속성들은 유일한 이름을 가져야 한다.
- 레코드들은 서로 간에 식별 가능해야 한다.

#### **제 2 정규화**

- 식별자가 아닌 모든 속성들은 식별자 전체 속성에 완전 종속되어야 한다.
- 이것을 물리 데이터 모델의 테이블로 말하면 기본키가 아닌 모든 칼럼들이 기본키에 종속적이어야 제 2 정규형을 만족할 수 있다는 것이다.

#### **제 3 정규화**

- 제 2 정규화를 만족하고 식별자를 제외한 나머지 속성들 간의 종속이 존재하면 안된다.

### **반정규화**

반정규화는 정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상과 개발(Development)과 운영(Maintenance)의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 의미한다. 반정규화는 데이터를 중복하여 성능을 향상시키기 위한 기법이라고 정의할 수 있고 좀 더 넓은 의미의 반정규화는 성능을 향상시키기 위해 정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정을 의미한다. 데이터 무결성이 깨질 수 있는 위험을 무릅쓰고 데이터를 중복하여 반정규화를 적용하는 이유는 데이터를 조회할 때 디스크 I/O량이 많아서 성능이 저하되거나 경로가 너무 멀어 조인으로 인한 성능저하가 예상되거나 칼럼을 계산하여 읽을 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다.

#### **반정규화 절차**

![image](post/SQL_반정규화절차.png){: width="85%" }

반정규화의 대상에 대해 다른 방법으로 처리

- 지나치게 많은 조인(JOIN)이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 뷰(VIEW)를 사용하면 이를 해결할 수도 있다.
- 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우에 클러스터링을 적용하거나 인덱스를 조정함으로써 성능을 향상시킬 수 있다.
- 대량의 데이터는 Primary Key의 성격에 따라 부분적인 테이블로 분리할 수 있다. 즉 파티셔닝 기법(Partitioning)이 적용되어 성능저하를 방지할 수 있다.
- 응용 애플리케이션에서 로직을 구사하는 방법을 변경함으로써 성능을 향상시킬 수 있다.

#### **테이블의 반정규화**

<table>
  <thead>
    <tr>
      <th class="text-center">기법분류</th>
      <th class="text-center">기법</th>
      <th class="text-center">내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" class="text-center">테이블병합</th>
      <td class="text-center">1:1 관계 테이블 병합</td>
      <td>1:1 관계를 통합하여 성능향상</td>
    </tr>
    <tr>
      <td class="text-center">1:M 관계 테이블 병합</td>
      <td>1:M 관계를 통합하여 성능향상</td>
    </tr>
    <tr>
      <td class="text-center">슈퍼/서브타입 테이블 병합</td>
      <td>슈퍼/서브 관계를 통합하여 성능향상</td>
    </tr>
    <tr>
      <th rowspan="2" class="text-center">테이블분할</th>
      <td class="text-center">수직분할</td>
      <td>컬럼단위의 테이블을 디스크 I/O를 분산처리하기 위해 테이블을 1:1로 분리하여 성능향상(트랜잭션의 처리되는 유형파악이 선행되어야 함)</td>
    </tr>
    <tr>
      <td class="text-center">수평분할</td>
      <td>로우단위로 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근의 효율성을 높여 성능을 향상하기 위해 로우단위로 테이블을 쪼갬(관계가 없음)</td>
    </tr>
    <tr>
      <th rowspan="4" class="text-center">테이블추가</th>
      <td class="text-center">중복테이블 추가</td>
      <td>다른 업무이거나 서버가 다른 경우 동일한 테이블구조를 중복하여 원격조인을 제거하여 성능을 향상</td>
    </tr>
    <tr>
      <td class="text-center">통계테이블 추가</td>
      <td>SUM, AVG 등을 미리 수행하여 계산해 둠으로써 조회 시 성능을 향상</td>
    </tr>
    <tr>
      <td class="text-center">이력테이블 추가</td>
      <td>이력테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 존재하는 방법</td>
    </tr>
    <tr>
      <td class="text-center">부분테이블 추가</td>
      <td>하나의 테이블을 전체 칼럼 중 자주 이용하는 집중화된 컬럼이 있을 경우, 디스크 I/O를 줄이기 위해 해당 컬럼들을 모아놓은 별도의 반정규화된 테이블을 생성</td>
    </tr>
  </tbody>
</table>

#### **컬럼 반정규화**

|           **반정규화 기법**            | **내용**                                                                                                                                                     |
| :------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------- |
|           **중복컬럼 추가**            | 조인시 성능저하를 예방하기 위해, 중복된 컬럼을 위치시킴                                                                                                      |
|           **파생컬럼 추가**            | 트랜잭션이 처리되는 시점에 계산에 의해 발생되는 성능저하를 예방하기 위해, 미리 계산하여 컬럼에 보관                                                          |
|        **이력테이블 컬럼추가**         | 대량의 이력데이터 처리 시 불특정 일 조회나 최근 값을 조회할 때 나타날 수 있는 성능저하를 예방하기 위해 기능성 컬럼(최근값 여부, 시작일자, 종료일자)을 추가함 |
|         **PK에 의한 컬럼추가**         | 복합의미를 갖는 PK를 단일속성으로 구성했을 때 발생되며, PK 안에 데이터가 존재하지만 성능향상을 위해 일반속성으로 포함하는 방법                               |
| **응용시스템 오작동을 위한 컬럼 추가** | 업무적으로는 의미가 없으나, 데이터 처리 시 오류로 인해 원래값으로 복구하길 원하는 경우 이전 데이터를 임시적으로 중복보관하는 방법                            |

### **대량 데이터 발생**

로우 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태가 로우체인(Row Chaining) 현상이다. 또한 로우마이그레이션(Row Migration)은 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당되는 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식이다. 로우체이닝과 로우마이그레이션이 발생하여 많은 블록에 데이터가 저장되면 데이터베이스 메모리에서 디스크와 I/O(입력/출력)가 발생할 때 불필요하게 I/O가 많이 발생하여 성능이 저하된다.

#### **대량 데이터 처리**

- **RANGE PARTITION** : 가장 많이 사용되는 파티셔닝의 기준이다. 대상 테이블이 날짜 또는 숫자값으로 분리가 가능하고 각 영역별로 트랜잭션이 분리된다면 RANGE PARTITION을 적용한다. 또한 RANGE PARTITION은 데이터 보관주기에 따라 테이블에 데이터를 쉽게 지우는 것이 가능하므로(파티션 테이블을 DROP하면 되므로) 데이터 보관주기에 따른 테이블 관리가 용이하다.
- **LIST PARTITION** : PK가 구성되어 있고 대량의 데이터가 있는 테이블이라면 값 각각에 의해 파티셔닝 되는 LIST PARTITION을 적용할 수 있다. LIST PARTITION은 대용량 데이터를 특정값에 따라 분리 저장할 수는 있으나 RANGE PARTITION과 같이 데이터 보관주기에 따라 쉽게 삭제하는 기능은 제공될 수 없다.
- **HASH PARTITION** : HASH PARTITION은 지정된 HASH 조건에 따라 해쉬 알고리즘이 적용되어 테이블이 분리되며 설계자는 테이블에 데이터가 정화갛게 어떻게 들어갔는지 알 수 없다. 역시 성능향상을 위해 사용하며 데이터 보관주기에 따라 쉽게 삭제하는 기능은 제공될 수 없다.

### **데이터베이스 구조와 성능**

#### **슈퍼/서브 타입 데이터 모델의 변환기술**

- 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성
- 슈퍼타입 + 서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입 + 서브타입 테이블로 구성
- 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성

#### **PK 순서를 결정하는 기준**

PK 순서를 결정하는 기준은 인덱스 정렬구조를 이해한 상태에서 인덱스를 효율적으로 이용할 수 있도록 PK 순서를 지정해야 한다. 즉 인덱스의 특징은 여러 개의 속성이 하나의 인덱스로 구성되어 있을 때 앞쪽에 위치한 속성의 값이 비교자로 있어야 인덱스가 좋은 효율을 나타낼 수 있다. 앞쪽에 위치한 속성값이 가급적 '=' 아니면 최소한 'BETWEEN' '<>'가 들어와야 인덱스를 이용할 수 있는 것이다.

### **분산 데이터베이스**

#### **분상 데이터베이스의 투명성**

- 분할 투명성(단편화) : 하나의 논리적 Relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장
- 위치 투명성 : 사용하려는 데이터의 저장 장소 명시 불필요. 위치정보가 System Catalog에 유지되어야 함
- 지역사상 투명성 : 지역 DBMS와 물리적 DB 사이의 Mapping 보장. 각 지역시스템 이름과 무관한 이름 사용 가능
- 중복 투명성 : DB 객체가 여러 site에 중복되어 있는지 알 필요가 없는 성질
- 장애 투명성 : 구성요소(DBMS, Computer)의 장애에 무관한 Transaction의 원자성 유지
- 병행 투명성 : 다수 Transaction 동시 수행 시 결과의 일관성 유지, Time Stamp, 분산 2단계 Locking을 이용 구현

#### **분산 데이터베이스 장단점**

| **장점**                                                                                                                                                                                                                                | **단점**                                                                                                                                                                                  |
| :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| - 지역 자치성, 점증적 시스템 용량 확장<br/> - 신뢰성과 가용성<br/> - 효용성과 융통성<br/> - 빠른 응답 속도와 통신비용 절감<br/> - 데이터의 가용성과 신뢰성 증가<br/> - 시스템 규모의 적절한 조절<br/> - 각 지역 사용자의 요구 수용 증대 | - 소프트웨어 개발 비용<br/> - 오류의 잠재성 증대<br/> - 처리 비용의 증대<br/> - 설계, 관리의 복잡성과 비용<br/> - 불규칙한 응답 속도<br/> - 통제의 어려움<br/> -데이터 무결성에 대한 위협 |
