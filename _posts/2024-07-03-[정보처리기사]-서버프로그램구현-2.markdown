---
title: "[정보처리기사] 서버 프로그램 구현 2"
date: 2024-07-03 00:34:00 +09:00
categories: [정보처리기사]
tags: [정보처리기사, 서버 프로그램 구현]
---

## 서버 프로그램 구현 2

#### **모듈(Module)**

- **<span style="background-color:#fff5b1">모듈화를 통해 분리된 시스템의 각 기능</span>**으로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등을 의미
- 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미함
- 하나 또는 몇 개의 논리적인 기능을 수행하기 위한 명령어들의 집합이라고도 할 수 있음
- 모듈의 독립성은 결합도(Coupling)와 응집도(Cohesion)에 의해 측정됨

#### **결합도(Coupling)**

- **<span style="background-color:#fff5b1">모듈 간에 상호 의존하는 정도</span>** 또는 두 모듈 사이의 연관 관계
- 결합도가 약할수록 품질이 높고, 강할수록 품질이 낮음
- **결합도의 종류와 강도**<br/>
  내용 결합도 > 공통 결합도 > 외부 결합도 > 제어 결합도 > 스탬프 결합도 > 자료 결합도

#### **결합도의 종류**

- **내용 결합도(Content Coupling)**<br/>
  한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도
- **공통(공유) 결합도(Common Coupling)**
  * 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
  * 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 사용하여 전역 변수를 갱신하는 방식으로 상호작용하는 때의 결합도
- **외부 결합도(External Coupling)**<br/>
  어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도
- **제어 결합도(Control Coupling)**
  * 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호나 제어 요소를 전달하는 결합도
  * 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도 현상이 발생하게 됨
- **스탬프(검인) 결합도(Stamp Coupling)**<br/>
  모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도
- **자료 결합도(Data Coupling)**<br/>
  모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도

#### **응집도(Cohesion)**

- **<span style="background-color:#fff5b1">모듈의 내부 요소들이 서로 관련되어 있는 정도</span>**
- 응집도가 강할수록 품질인 높고, 약할수록 품질이 낮음
- **응집도의 종류와 강도**<br/>
  기능적 응집도 > 순차적 응집도 > 교환적 응집도 > 절차적 응집도 > 시간적 응집도 > 논리적 응집도 > 우연적 응집도

#### **응집도의 종류**

- **기능적 응집도(Functional Cohesion)**<br/>
  모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도
- **순차적 응집도(Sequential Cohesion)**<br/>
  모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도
- **교환(통신)적 응집도(Communication Cohesion)**<br/>
  동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도
- **절차적 응집도(Procedural Cohesion)**<br/>
  모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
- **시간적 응집도(Temporal Cohesion)**<br/>
  특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
- **논리적 응집도(Logical Cohesion)**<br/>
  유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
- **우연적 응집도(Coincidental Cohesion)**<br/>
  모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도

#### **팬인/팬아웃**

- 팬인(Fan-In) : **<span style="background-color:#fff5b1">어떤 모듈을 제어하는 모듈의 수</span>**
- 팬아웃(Fan-Out) : **<span style="background-color:#fff5b1">어떤 모듈에 의해 제어되는 모듈의 수</span>**

#### **N-S 차트(Nassi-Schneiderman Chart)**

- **<span style="background-color:#fff5b1">논리의 기술에 중점을 두고 도형을 이용해 표현</span>**하는 방법
- GOTO나 화살표를 사용하지 않음
- 연속, 선택 및 다중 선택, 반복의 3가지 제어 논리 구조로 표현
- 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합

#### **IPC(Inter-Process Communication)**

- **<span style="background-color:#fff5b1">모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합</span>**
- 복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능
- **IPC의 대표 메소드 5가지**
  * 공유 메모리(Shared Memory)
  * 소켓(Socket)
  * 세마포어(Semaphores)
  * 파이프와 네임드 파이프(Pipes & named Pipes)
  * 메시지 큐잉(Message Queueing)

#### **테스트 케이스(Test Case)**

- 구현된 **<span style="background-color:#fff5b1">소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위한 테스트 항목에 대한 명세서</span>**
- ISO/IEC/IEEE 29119-3 표준에 따른 테스트 케이스의 구성 요소
  * 식별자 : 항목 식별자, 일련번호
  * 테스트 항목 : 테스트 대상(모듈 또는 기능)
  * 입력 명세 : 테스트 데이터 또는 테스트 조건
  * 출력 명세 : 테스트 케이스 수행 시 예상되는 출력 결과
  * 환경 설정 : 필요한 하드웨어나 소프트웨어의 환경
  * 특수 절차 요구 : 테스트 케이스 수행 시 특별히 요구되는 절차
  * 의존성 기술 : 테스트 케이스 간의 의존성

#### **공통 모듈 명세 기법의 종류**

공통 모듈은 **<span style="background-color:#fff5b1">여러 프로그램에서 공통으로 사용할 수 있는 모듈</span>**로, 이를 구현할 때는 해당 기능을 명확히 이해할 수 있도록 다음과 같은 명세 기법을 준수해야 함
- **정확성(Correctness)** : 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성함
- **명확성(Clarity)** : 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성함
- **완전성(Completeness)** : 시스템 구현을 위해 필요한 모든 것을 기술함
- **일관성(Consistency)** : 공통 기능들 간 상호 충돌이 발생하지 않도록 작성함
- **추적성(Traceability)** : 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성함

#### **재사용(Reuse)**

- **<span style="background-color:#fff5b1">이미 개발된 기능들을 새로운 시스템이나 기능 개발에 사용하기 적합하도록 최적화</span>**하는 작업
- 새로 개발하는데 필요한 비용과 시간을 절약할 수 있음
- 누구나 이해할 수 있고 사용이 가능하도록 사용법을 공개해야 함
- **재사용 규모에 따른 분류**
<table>
<tr>
<th style="white-space: pre;">함수와 객체</th>
<td >클래스나 메소드 단위의 소스 코드를 재사용함</td>
</tr>
<tr>
<th style="white-space: pre;">컴포넌트</th>
<td >컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용함</td>
</tr>
<tr>
<th style="white-space: pre;">애플리케이션</th>
<td >공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용함</td>
</tr>
</table>

#### **코드의 주요 기능**

- 코드(Code)는 **<span style="background-color:#fff5b1">자료의 분류 · 조합 · 집계 · 추출을 용이하게 하기 위해 사용하는 기호</span>**
- **코드의 주요 기능**
<table>
<tr>
<th style="white-space:pre;">식별 기능</th>
<td style="white-space:normal;">데이터 간의 성격에 따라 구분이 가능함</td>
</tr>
<tr>
<th style="white-space:pre;">분류 기능</th>
<td style="white-space:normal;">특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화할 수 있음</td>
</tr>
<tr>
<th style="white-space:pre;">배열 기능</th>
<td style="white-space:normal;">의미를 부여하여 나열할 수 있음</td>
</tr>
<tr>
<th style="white-space:pre;">표준화 기능</th>
<td style="white-space:normal;">다양한 데이터를 기준에 맞추어 표현할 수 있음</td>
</tr>
<tr>
<th style="white-space:pre;">간소화 기능</th>
<td style="white-space:normal;">복잡한 데이터를 간소화할 수 있음</td>
</tr>
</table>

#### **코드의 종류**

- **순차 코드(Sequence Code)**<br/>
  자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를 부여하는 방법으로, 순서 코드 또는 일련번호 코드라고도 함
- **블록 코드(Block Code)**<br/>
  코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법으로, 구분 코드라고도 함
- **10진 코드(Decimal Code)**<br/>
  코드화 대상 항목을 0~9까지 10진 분할하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 방법으로, 도서 분류식 코드라고도 함
- **그룹 분류 코드(Group Classification Code)**<br/>
  코드화 대상 항목을 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법
- **연상 코드(Mnemonic Code)**<br/>
  코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법
- **표의 숫자 코드(Significant Digit Code)**<br/>
  코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등의 물리적 수치를 그대로 코드에 적용시키는 방법으로, 유효 숫자 코드라고도 함
- **합성 코드(Combined Code)**<br/>
  필요한 기능을 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합하여 만드는 방법

#### **디자인 패턴(Design Pattern)**

- **<span style="background-color:#fff5b1">모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제</span>**
- 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성되어 있음
- GOF의 디자인 패턴은 생성 패턴, 구조 패턴, 행위 패턴으로 구분됨

#### **생성 패턴(Creational Pattern)**

클래스나 객체의 생성과 참조 과정을 정의하는 패턴

- **추상 팩토리(Abstract Factory)**
  * 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관 · 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현하는 패턴
  * 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능
- **빌더(Builder)**
  * 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성하는 패턴
  * 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있음
- **팩토리 메소드(Factory Method)**
  * 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴
  * 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당
  * 가상 생성자(Virtual Constructor) 패턴이라고도 함
- **프로토타입(Prototype)**
  * 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
  * 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 주로 이용
- **싱글톤(Singleton)**
  * 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없는 패턴
  * 클래스 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화할 수 있음

#### **구조 패턴(Structural Pattern)**

구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴

- **어댑터(Adapter)**
  * 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
  * 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용
- **브리지(Bridge)**
  * 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴
  * 기능과 구현을 두 개의 별도 클래스로 구현
- **컴포지트(Composite)**
  * 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
  * 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있음
- **데코레이터(Decorator)**
  * 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
  * 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현
- **퍼싸드(Facade)**
  * 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
  * 서브 클래스들 사이의 통합 인터페이슬 제공하는 Wrapper 객체가 필요
- **플라이웨이트(Flyweight)**
  * 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴
  * 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용할 수 있음
- **프록시(Proxy)**
  * 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴
  * 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용함

#### **행위 패턴(Behavioral Pattern)**

클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴

- **책임 연쇄(Chain of Responsibility)**
  * 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
  * 요청을 처리할 수 있는 각 객체들이 고리(Chain)로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어감
- **커맨드(Command)**
  * 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
  * 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화함
- **인터프리터(Interpreter)**
  * 언어에 문법 표현을 정의하는 패턴
  * SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용
- **반복자(Iterator)**
  * 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
  * 내부 표현 방법의 노출 없이 순차적인 접근이 가능
- **중재자(Mediator)**
  * 수많은 객체들 간의 복잡한 상호작용(Interface)을 캡슐화하여 객체로 정의하는 패턴
  * 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있음
- **메멘토(Memento)**
  * 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
  * <kbd>Ctrl</kbd> + <kbd>Z</kbd>와 같은 되돌리기 기능을 개발할 때 주로 이용
- **옵서버(Observer)**
  * 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
  * 일대다의 의존성을 정의
  * 주로 분산된 시스템 간에 이벤트를 생성·발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 이용
- **상태(State)**
  * 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
  * 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리
- **전략(Strategy)**
  * 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
  * 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘의 변경이 가능
- **템플릿 메소드(Template Method)**
  * 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
  * 유사한 서브 클래스를 묶어 공통된 내부를 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해줌
- **방문자(Visitor)**
  * 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴
  * 분리된 처리 기능 각 클래스를 방문(Visit)하여 수행

#### **배치 프로그램(Batch Program)**

- 사용자와의 상호 작용 없이 **<span style="background-color:#fff5b1">여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하도록 만든 프로그램</span>**
- **배치 프로그램의 필수 요소**
<table>
<tr>
<th style="white-space: pre;">대용량 데이터</th>
<td >대량의 데이터를 가져오거나,전달하거나, 계산하는 등의 처리가 가능해야 함</td>
</tr>
<tr>
<th style="white-space: pre;">자동화</th>
<td >심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행되어야 함</td>
</tr>
<tr>
<th style="white-space: pre;">견고성</th>
<td >잘못된 데이터나 데이터 중복 등의 상황으로 중단되는 일 없이 수행되어야 함</td>
</tr>
<tr>
<th style="white-space: pre;">안정성/신뢰성</th>
<td >오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 함</td>
</tr>
<tr>
<th style="white-space: pre;">성능</th>
<td >
<ul>
<li>다른 응용 프로그램의 수행을 방해하지 않아야 함</li>
<li>지정된 시간 내에 처리가 완료되어야 함</li>
</ul>
</td>
</tr>
</table>
